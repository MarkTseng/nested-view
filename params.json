{"tagline":"Declarative nested Backbone/Handlebars views.","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Nested-view","body":"# NestedView\r\n\r\nDeclarative nested Backbone/Handlebars views.  Render nested view hierarchies in both the browser and in Node.js.\r\n\r\n## Usage\r\n\r\nIn your Handlebars templates, use the `{{view}}` helper to declare nested child views.\r\n\r\n### Example\r\n\r\n#### `index_view.hbs`\r\n\r\n    <h1>Hello, {{user.name}}.</h1>\r\n    {{view \"user_detail_view\" context=user}}\r\n\r\n#### `user_detail_view.hbs`\r\n\r\n     <li>Name: {{name}}</li>\r\n     <li>Email: {{email}}</li>\r\n\r\n#### `index_view.js`\r\n\r\n    var IndexView = NestedView.extend({\r\n      name: 'index_view'\r\n    });\r\n\r\n#### `user_detail_view.js`\r\n\r\n    var UserDetailView = NestedView.extend({\r\n      name: 'user_detail_view',\r\n      tagName: 'ul'\r\n    });\r\n\r\n#### `application.js`\r\n\r\n\tvar data = {user: {name: 'Spike', email: 'spike@example.info'}};\r\n    var indexView = new IndexView(data);\r\n    \r\n    // On the server, grab the view hierarchy's HTML using NestedView::getHtml().\r\n    console.log(indexView.getHtml());\r\n    \r\n    // In the client, just call render.\r\n    console.log(indexView.render().el);\r\n    \r\nOutput:\r\n    \r\n    <div data-view=\"index_view\" data-cid=\"view1\">\r\n\t  <h1>Hello, Spike.</h1>\r\n\t  <ul data-view=\"user_detail_view\" data-cid=\"view2\">\r\n\t    <li>Name: Spike</li>\r\n\t    <li>Email: spike@example.info</li>\r\n\t  </ul>\r\n    </div>\r\n    \r\n### Accessing child views\r\n\r\n`NestedView` helps you construct modular, DRY view components. An important element in this design is to not allow child views to know anything about the world around them, including their parent. Instead, parent views have a reference to each child view, and child views communicate with the world around them by emitting and listening to events.\r\n\r\nHere's an example of how to bind to an event on a child view.\r\n\r\n#### `user_detail_view.js`\r\n\r\n    var UserDetailView = NestedView.extend({\r\n      name: 'user_detail_view',\r\n      tagName: 'ul',\r\n      events: {\r\n        'click li': 'selectRow'\r\n      },\r\n      selectRow: function(e) {\r\n        this.trigger('row_selected', e.currentTarget);\r\n      }\r\n    });\r\n\r\n#### `index_view.js`\r\n\r\n    var IndexView = NestedView.extend({\r\n      name: 'index_view',\r\n      postRender: function(e) {\r\n        this.childViews['user_detail_view'].on('row_selected', function(domEl){\r\n          // do something\r\n          console.log(domEl);\r\n        });\r\n      }\r\n    });\r\n\r\n##  Methods\r\n\r\n### `view.render()`\r\n\r\nRender is called only in the browser environment. The render method is implemented for you out of the box -- you should never override it. It renders the DOM based on the HTML returned by `view.getHtml({outerHtml: false})` and then initializes any child views that are present in that HTML. It calls `view.postRender()` when it's done, so you can do anything that needs access to the DOM or to child views.\r\n\r\n### `view.postRender()`\r\n\r\nCalled after the view and its child views are rendered to the DOM, and child view instances have been bound to child view DOM elements. This method is wehre you put any initialization code that needs access to the DOM, such as setting up slideshows, or anything that needs access to child views, such as binding to their events.\r\n\r\n### `view.getHtml([options])`\r\n\r\nReturns the HTML of that view and all of its subviews. It combines the template function returned by `view.getTemplate()` and the template data returned by `view.getTemplateData()` to produce the view's HTML.\r\n\r\n#### `options.outerHtml ?= true`\r\n\r\nIf you pass `{outerHtml: false}`, then it just returns the inner HTML. This is used by `view.render()`.\r\n\r\n### `view.getTemplate()`\r\n\r\nThis method returns the compiled Handlebars template that is used to render this view. The default implementation is almost surely not compatible with your particular application setup. Rather than overriding this for every view, it is useful to subclass `NestedView` for your own needs, and customize the `getTemplate()` method once.\r\n\r\n### `view.getTemplateData()`\r\n\r\nHere is where you customize what data gets passed to the Handlebars template for producing HTML. This method can function as a presenter or view-model. The default implementation returns `this.model.toJSON()` if a model is present, `{collection: this.collection.toJSON()}` if a collection is present, and otherwise just returns `_.clone(this.options)`. \r\n    "}